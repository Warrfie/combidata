{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#combidata-documentation","title":"Combidata Documentation","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the Combidata documentation! Combidata is a case-oriented library designed for compositional testing of combinatorics in IT product functionalities. This library aims to simplify and streamline the process of testing various combinations of functionalities, ensuring that your IT products are robust, reliable, and free of combinatorial bugs.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install combidata\n</code></pre>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>All entities<ul> <li>Process</li> <li>Cases</li> <li>Combination</li> <li>DataGenerator</li> </ul> </li> <li>Quick Start Guide</li> </ul>"},{"location":"#what-is-compositional-testing","title":"What is Compositional Testing?","text":"<p>Compositional testing is a testing approach that focuses on testing individual components of a system in isolation and then testing them in combination. This method ensures that each component functions as expected on its own and in conjunction with other components. Combidata leverages this approach to provide a comprehensive testing solution for IT products, ensuring that all possible combinations of functionalities are tested and validated.</p>"},{"location":"#features-of-combidata","title":"Features of Combidata","text":"<ul> <li>Case-Oriented: Tailored for specific test cases, ensuring targeted and effective testing.</li> <li>Comprehensive Combinatorial Testing: Tests all possible combinations of functionalities, ensuring thorough coverage.</li> <li>Intuitive Interface: Easy-to-use methods and functions for quick test setup and execution.</li> <li>Scalable: Suitable for both small-scale applications and large-scale IT systems.</li> <li>Integration Capabilities: Can be integrated with other testing tools and platforms for a seamless testing experience.</li> </ul>"},{"location":"#getting-started-with-combidata","title":"Getting Started with Combidata","text":"<ol> <li>Installation: Install Combidata using pip or other package managers.</li> <li>Configuration: Set up your test environment, specifying the functionalities and combinations you want to test.</li> <li>Execution: Run your tests using Combidata's intuitive interface.</li> <li>Results Analysis: Analyze the results, identify potential issues, and refine your tests as needed.</li> </ol>"},{"location":"#use-cases-and-applications","title":"Use Cases and Applications","text":"<ul> <li>E-commerce Platforms: Test various combinations of product attributes, payment methods, and user interactions.</li> <li>Content Management Systems: Validate different combinations of content types, user roles, and permissions.</li> <li>Financial Applications: Test different scenarios of transactions, account types, and user actions.</li> <li>And many more: Any IT product with multiple functionalities can benefit from Combidata's comprehensive testing approach.</li> </ul>"},{"location":"#best-practices","title":"Best Practices","text":"<ul> <li>Always start with individual component testing before moving on to combinatorial testing.</li> <li>Regularly update your test cases to reflect changes in functionalities.</li> <li>Use Combidata in conjunction with other testing tools for a holistic testing approach.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit pull requests, report bugs, or suggest new features through the GitHub repository. We appreciate your help in improving Combidata!</p>"},{"location":"#license","title":"License","text":"<p>Combidata is released under the MIT License. See the LICENSE file for more details.</p>"},{"location":"#support","title":"Support","text":"<p>If you need help with Combidata or have any questions, please open an issue on GitHub or contact the maintainers directly </p> <p>Telegram \u2014 https://t.me/sasisochka</p> <p>Linkedin \u2014 https://www.linkedin.com/in/yasasisochka/</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Thank you for choosing Combidata for your combinatorial testing needs. We're committed to helping you ensure the reliability and robustness of your IT products. Your input will helps make Combidata a better tool for everyone!</p> <p>And a special thanks to JetBrains for their best software and License for Open Source Development.</p> <p></p>"},{"location":"Cases/","title":"Cases","text":""},{"location":"Cases/#combidata-case-user-guide","title":"Combidata Case User Guide","text":""},{"location":"Cases/#introduction","title":"Introduction","text":"<p>In Combidata, a <code>Case</code> represents a specific test scenario or variation. It is defined using a dictionary structure with specific keys that have predefined meanings. This guide will help you understand how to define a <code>Case</code> and what each key represents.</p>"},{"location":"Cases/#defining-a-case","title":"Defining a Case","text":"<p>A <code>Case</code> is defined as a dictionary. Each key-value pair in the dictionary corresponds to a specific attribute or property of the case. Here's a breakdown of the keys you can use:</p>"},{"location":"Cases/#reserved-keys","title":"Reserved Keys:","text":"<ul> <li>name: A descriptive name for the case. This name should be unique across the entire test to avoid confusion.</li> <li>gen_func: A function responsible for generating values for the case. It will accept <code>value</code> or <code>options</code> if they are provided.</li> <li>value: The primary value associated with the case. If <code>gen_func</code> is provided, this will be the first argument for that function. This can be of any data type.</li> <li>options: A dictionary that provides additional parameters or arguments for the <code>gen_func</code>. The key in this dictionary will be the argument name for the function, and the associated value will be the argument value.</li> <li>is_presented: A boolean flag indicating if the case should be exported or considered in the final output.</li> <li>requirements: Specifies dependencies on other fields. It's a dictionary where keys are field names and values are lists of field modes that this case depends on.</li> <li>type: Indicates the type of test this case belongs to. It should be a string. For example, \"error\" might indicate this case is meant to test error scenarios.</li> </ul>"},{"location":"Cases/#additional-fields","title":"Additional Fields:","text":"<p>Any key in the <code>Case</code> dictionary that is not one of the reserved keys mentioned above is considered an \"Additional Field\". These fields are user-defined and can be used to store any extra information or metadata related to the case.</p> <p>For example, in the provided sample, the key \"error\" with its associated dictionary (<code>{\"code\": 400, \"message\": \"Sample Error Message\"}</code>) is an additional field. It provides extra information about the error scenario being tested.</p>"},{"location":"Cases/#accessing-additional-fields","title":"Accessing Additional Fields","text":"<p>You can access the values of additional fields just like you would access any key-value pair in a dictionary:</p> <pre><code>case_value = my_case[\"additional_field_name\"]\n</code></pre>"},{"location":"Cases/#example","title":"Example:","text":"<p>Here's a sample <code>Case</code> definition for better understanding:</p> <pre><code>relatives[\"cases\"][\"FIELD_NAME\"] = {\n    \"MODE_CODE\": {\n        \"value\": \"Sample Value\",\n        \"name\": \"Descriptive Name for the Case\",\n        \"requirements\": {\"ANOTHER_FIELD\": [\"MODE_CODE_1\", \"MODE_CODE_2\"]},\n        \"type\": \"error\",\n        \"error\": {\"code\": 400, \"message\": \"Sample Error Message\"}\n    },\n    ...\n}\n</code></pre> <p>In this example:</p> <ul> <li> <p>\"FIELD_NAME\" is the name of the field being tested.</p> </li> <li> <p>\"MODE_CODE\" is a unique code representing a specific test scenario or variation for \"FIELD_NAME\".</p> </li> <li> <p>The dictionary associated with \"MODE_CODE\" defines the properties of that specific test scenario.</p> </li> </ul>"},{"location":"Cases/#conclusion","title":"Conclusion","text":"<p>Defining a <code>Case</code> in Combidata involves setting up a dictionary with specific keys that have predefined meanings. The flexibility of the structure allows you to define a wide range of test scenarios and variations, making it a powerful tool for comprehensive testing.</p>"},{"location":"Combination/","title":"Combination","text":""},{"location":"Combination/#combination-class-documentation","title":"Combination Class Documentation","text":""},{"location":"Combination/#overview","title":"Overview:","text":"<p>The <code>Combination</code> class represents a combination of test data and associated processes. It plays a crucial role in the test generation process and is utilized within various process classes. It provides a structured way to manage and manipulate test data during the execution of test processes.</p>"},{"location":"Combination/#key-features","title":"Key Features:","text":"<ul> <li> <p>Integration with Process Classes: The <code>Combination</code> class is passed as an argument to process classes, making it an essential component for test generation and execution.</p> </li> <li> <p>Cache Usage: Within the processes, the <code>cache</code> attribute of the <code>Combination</code> class can be utilized. This dictionary attribute allows for the addition, modification, and retrieval of key-value pairs, facilitating dynamic data storage and manipulation during test execution.</p> </li> <li> <p>Emergency Stop: In unforeseen situations where a process needs to be halted immediately, the <code>step_done</code> attribute can be set to \"STOP\" (in uppercase). This signals an immediate termination of the current process.</p> </li> <li> <p>Access in Generation Function: The <code>Combination</code> class can be accessed within the Generation function. By using the <code>Options</code> key and setting its value to the reserved word \"combination\", the class instance can be retrieved and manipulated.</p> </li> </ul>"},{"location":"Combination/#usage","title":"Usage:","text":"<p>When defining a process, ensure that the <code>Combination</code> class is passed as an argument. This allows for seamless integration and data flow between the test generation logic and the processes. The <code>cache</code> attribute can be used for temporary data storage, and in case of any unexpected issues, the process can be stopped by setting <code>step_done</code> to \"STOP\".</p>"},{"location":"Combination/#attributes","title":"Attributes:","text":"<ul> <li> <p>test_seed: A dictionary that is formed during the ST CombineProcess. It's optional and might not be used if the ST CombineProcess is not invoked.</p> </li> <li> <p>formed_data: A dictionary that is formed during the ST FormProcess. It's optional and might not be used if the ST FormProcess is not invoked.</p> </li> <li> <p>step_done: A string indicating the last successful step.</p> </li> <li> <p>init_lib: A dictionary that is a copy of the initial library.</p> </li> <li> <p>main_case: An instance of the main case.</p> </li> <li> <p>template: A dictionary that holds the export template.</p> </li> <li> <p>tools: A dictionary containing intangible user tools.</p> </li> <li> <p>generated_data: A dictionary holding all data generated during the ST Generate step.</p> </li> <li> <p>other_cases: A dictionary storing other cases that take part in the test.</p> </li> <li> <p>cache: A dictionary that serves as a store for your steps and processes. It can be used to store any data that might be needed during the execution of processes.</p> </li> <li> <p>workflow: Either a list or tuple containing processes.</p> </li> </ul> <p>This documentation provides a comprehensive overview of the <code>Combination</code> class, its attributes, and how it can be used within process functions.</p>"},{"location":"DataGenerator/","title":"DataGenerator","text":""},{"location":"DataGenerator/#datagenerator-class-documentation","title":"DataGenerator Class Documentation","text":""},{"location":"DataGenerator/#overview","title":"Overview:","text":"<p>The <code>DataGenerator</code> class serves as a pivotal component in the test generation framework. Its primary function is to produce test data based on a provided library of test cases and specific configurations. By doing so, it ensures that the generated tests adhere to the given criteria, such as possible fields, modes, and types of cases.</p>"},{"location":"DataGenerator/#initialization","title":"Initialization:","text":"<p>The <code>DataGenerator</code> class can be initialized in various ways, depending on the requirements and the level of specificity needed.</p>"},{"location":"DataGenerator/#basic-initialization","title":"Basic Initialization:","text":"<p>The simplest way to initialize the <code>DataGenerator</code> class is by providing just the test library:</p> <pre><code>generator = DataGenerator(library=your_test_library)\n</code></pre>"},{"location":"DataGenerator/#full-initialization","title":"Full Initialization:","text":"<p>For a more detailed configuration, you can provide additional parameters:</p> <pre><code>generator = DataGenerator(\n    library=your_test_library,\n    banned_fields=[\"field1\", \"field2\"],\n    possible_fields=[\"field3\", \"field4\"],\n    possible_modes={\"mode1\": \"value1\", \"mode2\": \"value2\"},\n    type_of_cases=[\"type1\", \"type2\"],\n    types_for_generation=[\"type3\", \"type4\"],\n    amount=10\n)\n</code></pre>"},{"location":"DataGenerator/#simplified-initialization","title":"Simplified Initialization:","text":"<p>In cases where you only want to specify the types of cases and types for generation as strings:</p> <pre><code>generator = DataGenerator(\n    library=your_test_library,\n    type_of_cases=\"type1\",\n    types_for_generation=\"type3\"\n)\n</code></pre>"},{"location":"DataGenerator/#usage-examples","title":"Usage Examples:","text":""},{"location":"DataGenerator/#running-the-datagenerator","title":"Running the DataGenerator:","text":"<p>To execute the test generation process, use the <code>run</code> method:</p> <pre><code>generator.run()\n</code></pre>"},{"location":"DataGenerator/#retrieving-a-single-test-case","title":"Retrieving a Single Test Case:","text":"<p>If you wish to obtain a specific test case, you can use the appropriate method:</p> <pre><code># This method needs to be verified in the code for its exact name and usage\nsingle_test_case = generator.get_single_test_case(case_name=\"desired_case_name\")\n</code></pre>"},{"location":"DataGenerator/#accessing-generated-combinations","title":"Accessing Generated Combinations:","text":"<p>Post generation, you can access the combinations created:</p> <pre><code>combinations = generator.combinations\nfor combination_name, combination_instance in combinations.items():\n    # Process each combination as needed\n</code></pre>"},{"location":"DataGenerator/#result-conclusion","title":"Result Conclusion:","text":"<p>Upon completion of the test generation process, the results can be accessed and processed as required. The <code>combinations</code> attribute of the <code>DataGenerator</code> class holds the generated test data, with each combination being an instance of the <code>Combination</code> class. This allows for further manipulation, analysis, or export of the test data as needed.</p> <p>Note: Always refer to the actual code implementation for any updates or changes to the methods and their usages.</p>"},{"location":"Installation/","title":"Installation","text":""},{"location":"Installation/#installation","title":"Installation","text":"<p>This package is tested with Python 3.9-3.11 and Pypy 3. There are two ways to install the library:</p> <ul> <li>Installation using pip (a Python package manager):</li> </ul> <p><pre><code>pip install combidata\n</code></pre> * Installation from source (requires git):</p> <p><pre><code>git clone https://github.com/Warrfie/combidata\ncd combidata\npython setup.py install\n</code></pre> or: <pre><code>pip install git+https://github.com/Warrfie/combidata\n</code></pre></p> <p>It is generally recommended to use the first option.</p> <p>Package is still under development, and it has regular updates, do not forget to update it regularly by calling <pre><code>pip install combidata --upgrade\n</code></pre></p>"},{"location":"Process/","title":"Process","text":""},{"location":"Process/#process-class-documentation","title":"Process Class Documentation","text":""},{"location":"Process/#overview","title":"Overview","text":"<p>The <code>Process</code> class represents a test step or process within the Combidata framework. It is designed to execute a specific function (referred to as <code>given_func</code>) as part of the test step. This function will continue to run until it returns <code>True</code>, indicating the completion of the process.</p>"},{"location":"Process/#attributes","title":"Attributes","text":"<p>func (function): </p> <ul> <li>Description: A function that is executed as part of the test step.</li> <li>Requirement: This function must return <code>True</code> to indicate the completion of the process. It must also accept an argument of type <code>Combination</code>.</li> <li>Example: </li> </ul> <pre><code>def sample_func(combination):\n    # Your logic here\n    return True\n</code></pre> <p>name (str):</p> <ul> <li>Description: A unique identifier for the process.</li> <li>Requirement: The <code>name</code> must be unique across all instances to avoid conflicts.</li> <li>Example:</li> </ul> <pre><code>process_name = \"sample_process\"\n</code></pre>"},{"location":"Process/#usage","title":"Usage","text":"<p>To define a test step, instantiate the <code>Process</code> class by providing the necessary attributes:</p> <pre><code>from combidata import Process\n\ndef sample_func(combination):\n    # Your logic here\n    return True\n\nprocess_instance = Process(name=\"sample_process\", given_func=sample_func)\n</code></pre>"},{"location":"Process/#notes","title":"Notes","text":"<ul> <li>Ensure that the <code>name</code> attribute is unique to avoid any potential conflicts during execution.</li> <li>The <code>given_func</code> is essential and must always return a boolean value (<code>True</code> or <code>False</code>). It should return <code>True</code> to indicate the successful completion of the process.</li> <li>The <code>given_func</code> must accept an argument of type <code>Combination</code>. This allows you to access and manipulate the combination data within the function.</li> </ul>"},{"location":"QSG/","title":"Quick Start Guide","text":""},{"location":"QSG/#quick-start-guide","title":"Quick Start Guide","text":"<p>Welcome to Combidata, a case-oriented library designed for compositional testing of combinatorics in IT product functionalities. This guide will walk you through the basic structure and usage of Combidata to help you get started quickly.</p>"},{"location":"QSG/#overview","title":"Overview","text":"<p>Combidata allows you to define test cases and workflows, and then generate test data based on these definitions. It provides a flexible and powerful way to handle combinatorial testing, ensuring that all possible combinations of inputs are tested.</p>"},{"location":"QSG/#structure-of-input-library","title":"Structure of Input Library","text":"<p>The main structure of the input library is as follows:</p> <pre><code>library = {\n    \"cases\": {},\n    \"workflow\": (ST_COMBINE, ST_GENERATE, ST_FORM),\n    \"tools\": {},\n    \"template\": {}\n}\n</code></pre> <ul> <li>cases: Contains a library instance with all your defined test cases.</li> <li>workflow: Stores a tuple or list of processes to be executed during the test generation.</li> <li>tools: A dictionary of utilities and functions that can be used within the processes.</li> <li>template: Defines the format for exporting the test results.</li> </ul>"},{"location":"QSG/#defining-cases","title":"Defining Cases","text":"<p>Cases are the heart of Combidata. They define the different test scenarios you want to cover. Each case is associated with a field, and each field can have multiple cases. Here's a brief overview of the case structure:</p> <pre><code>library[\"cases\"][\"FIELD_NAME\"] = {\n    \"CASE_CODE\": {\n        \"name\": \"Description of the case\",\n        \"gen_func\": function_for_generation,\n        \"value\": \"Value or pattern for the case\",\n        \"options\": {\"key\": \"value\"},\n        \"is_presented\": True/False,\n        \"requirements\": {\"AnotherField\": \"CaseCode\"},\n        \"type\": \"Type of the case\"\n    }\n}\n</code></pre> <ul> <li>name: A unique description of the case.</li> <li>gen_func: A function that generates the test data for the case.</li> <li>value: The value or pattern that the test data should match.</li> <li>options: Additional options for the generation function.</li> <li>is_presented: Determines if the case should be included in the exported results.</li> <li>requirements: Specifies dependencies on other fields.</li> <li>type: The type of the case, used for filtering during test generation.</li> </ul>"},{"location":"QSG/#workflow","title":"Workflow","text":"<p>The workflow defines the sequence of processes that Combidata will execute during test generation. You can define a single workflow or multiple workflows based on your testing needs.</p> <pre><code>\"workflow\": (ST_COMBINE, ST_GENERATE, ST_FORM)\n</code></pre> <p>Each process in the workflow is an instance of the <code>Process</code> class, which takes a name and a function. The function should return <code>True</code> when it's done, or you can stop the workflow prematurely using <code>combination.step_done = \"STOP\"</code>.</p>"},{"location":"QSG/#tools","title":"Tools","text":"<p>The tools section is a warehouse for utilities, functions, or any other resources you might need during test generation. You can access these tools within your processes using <code>combination.tools[\"TOOL_NAME\"]</code>.</p>"},{"location":"QSG/#template","title":"Template","text":"<p>The template defines the format of the exported test results. It's a simple dictionary where each key is a field name, and the value is the case code. Combidata will replace these placeholders with the generated test data.</p>"},{"location":"QSG/#running-tests","title":"Running Tests","text":"<p>Once you've defined your library, you can create an instance of the <code>DataGenerator</code> class and call its <code>run()</code> method to generate test data. Here's a simple example:</p> <pre><code>generator = DataGenerator(library)\ngenerator.run()\n</code></pre> <p>You can then use the generated combinations in your tests. For instance, using pytest:</p> <pre><code>@pytest.mark.parametrize(\"combination_name\", generator.combinations.keys())\ndef test(combination_name):\n    combination = generator.combinations[combination_name]\n    combination.run()\n    # Your test assertions here\n</code></pre>"},{"location":"QSG/#conclusion","title":"Conclusion","text":"<p>Combidata provides a powerful and flexible way to handle combinatorial testing in IT products. By defining cases, workflows, and templates, you can ensure comprehensive test coverage for your product's functionalities. Whether you're new to compositional testing or an experienced tester, Combidata offers the tools and flexibility you need to achieve your testing goals.</p>"}]}